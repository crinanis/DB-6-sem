-- 1. Создание таблицы Report1
CREATE TABLE Report1 (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    xm XMLTYPE
);

truncate table report1;

-- 2. Создание функции CreateXML
CREATE OR REPLACE FUNCTION CreateXML
RETURN XMLTYPE
AS
  xml XMLTYPE;
  b NVARCHAR2(600);
BEGIN
  b := 'select SYSTIMESTAMP, owner_id, owner_name, owner_surname, owner_patronimyc, owner_address, owner_number, owner_passport FROM owners';

  dbms_output.put_line(b);

  SELECT xmlelement("XML",
      xmlelement(evalname('Owners'),
      dbms_xmlgen.getxmltype(b))) --generate xml document based on b
  INTO xml
  FROM dual;
  
  RETURN xml;
END CreateXML;

SET SERVEROUTPUT ON
SELECT (CreateXML).GETSTRINGVAL() FROM dual; -- get data in a row from xml

-- 3. Создание процедуры INSERTXML
CREATE OR REPLACE PROCEDURE INSERTXML(
    id INTEGER,
    x IN XMLTYPE)
IS
BEGIN
  INSERT INTO Report1 (id, xm)
  VALUES (id, x);
  COMMIT;
END;

BEGIN
  INSERTXML(1, CreateXML);
END;

SELECT * FROM Report1;

-- 4. Создание индекса xml_index
drop index xml_index;
CREATE INDEX xml_index ON Report1(extractvalue(xm, '/XML/Owners/ROWSET/ROW/owner_id[0]/text()')); --выражение, на основе которого будет создан индекс.

-- 5. Создание процедуры FINDXML
CREATE OR REPLACE PROCEDURE FINDXML(word IN VARCHAR2, aa OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN aa FOR
    SELECT x.owner_name
    FROM Report1 r,
      XMLTABLE('/XML/Owners/ROWSET/ROW' PASSING r.xm        --разбивает XML-данные на отдельные столбцы для дальнейшего выбора.
        COLUMNS owner_name VARCHAR2(100) PATH 'OWNER_NAME',
                owner_id   VARCHAR2(100) PATH 'OWNER_ID[0]'
      ) x
    WHERE x.owner_id = word;
END FINDXML;

DECLARE
  word VARCHAR2(4000) := '1';
  result_cursor SYS_REFCURSOR;
  owner_name VARCHAR2(100);
BEGIN
  FINDXML(word, result_cursor);
  LOOP
    FETCH result_cursor INTO owner_name;
    EXIT WHEN result_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(owner_name);
  END LOOP;
  CLOSE result_cursor;
END;


SET SERVEROUTPUT ON

